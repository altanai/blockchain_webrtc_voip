include_file "modules.cfg"

####### Routing Logic ########

request_route {

	xlog("L_INFO", " ---------------- request_route, methods <$rm> <$Rp>\n");
	if (($Rp == MY_WS_PORT || $Rp == MY_WSS_PORT)	&& !(proto == WS || proto == WSS)) {
		xlog("L_WARN", "SIP request received on $Rp\n");
		sl_send_reply("403", "Forbidden");
		exit;
	}

	# per request initial checks
    # 	route(REQINIT);

	if (nat_uac_test(64)) {
		# NAT traversal  WebSocket
		force_rport();
		if (is_method("REGISTER")) {
			fix_nated_register();
		} else {
			if (!add_contact_alias()) {
				xlog("L_ERR", "Error aliasing contact <$ct>\n");
				sl_send_reply("400", "Bad Request");
				exit;
			}
		}
	}

	# handle requests within SIP dialogs
	route(WITHINDLG);

	### only initial requests (no To tag)

	# CANCEL processing
	if (is_method("CANCEL")) {
		if (t_check_trans()) {
			t_relay();
		}
		exit;
	}

	t_check_trans();


	# record routing for dialog forming requests (in case they are routed)
	# - remove preloaded route headers
	remove_hf("Route");
	if (is_method("INVITE")) {
		xlog("L_INFO", " ---------------- request method INVITE , do reord_route \n");
		record_route();
	}

	# handle registrations
	route(REGISTRAR);

	if ($rU==$null) {
		# request with no Username in RURI
		sl_send_reply("484", "Address Incomplete");
		exit;
	}

	# user location service
	route(LOCATION);

	route(RELAY);
}

route[RELAY] {
	xlog("L_INFO", " ---------------- do relay \n");
	if (!t_relay()) {
		sl_reply_error();
	}
	exit;
}

# Per SIP request initial checks
route[REQINIT] {
	xlog("L_INFO", " ---------------- do initial request checks \n");
	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483", "Too Many Hops");
		exit;
	}

	if (!sanity_check("1511", "7")) {
		xlog("Malformed SIP message from $si:$sp\n");
		exit;
	}

	if (uri == myself && is_method("OPTIONS") && !(uri=~"sip:.*[@]+.*")) {
		options_reply();
		exit;
	}
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
	if (has_totag()) {
		# sequential request withing a dialog should
		# take the path determined by record-routing
		if (loose_route()) {
			if ($du == "") {
				if (!handle_ruri_alias()) {
					xlog("L_ERR", "Bad alias <$ru>\n");
					sl_send_reply("400", "Bad Request");
					exit;
				}
			}
			route(RELAY);
		} else {
			if ( is_method("ACK") ) {
				if ( t_check_trans() ) {
					# no loose-route, but stateful ACK;
					# must be an ACK after a 487
					# or e.g. 404 from upstream server
					t_relay();
					exit;
				} else {
					# ACK without matching transaction...
					# ignore and discard
					exit;
				}
			}
			sl_send_reply("404", "Not Found");
		}
		exit;
	}
}

# Handle SIP registrations
route[REGISTRAR] {
	if (is_method("REGISTER")) {
		if (!save("location")) {
			sl_reply_error();
		}
		exit;
	}
}

# USER location service
route[LOCATION] {
	xlog("L_INFO", " Location service \n");
	if (!lookup("location")) {
		$var(rc) = $rc;
		t_newtran();
		switch ($var(rc)) {
		case -1:
			send_reply("480", "Temporarily Unavailable");
			exit;
		case -2:
			send_reply("405", "Method Not Allowed");
			exit;
		case -3:
			send_reply("500", "Server Internal Error");
			exit;
		}
	}
}

onreply_route {
	if (($Rp == MY_WS_PORT || $Rp == MY_WSS_PORT) && !(proto == WS || proto == WSS)) {
		xlog("L_WARN", "SIP response received on $Rp\n");
		drop;
	}

	if (nat_uac_test(64)) {
		# Do NAT traversal stuff for replies to a WebSocket connection
		# - even if it is not behind a NAT!
		# This won't be needed in the future if Kamailio and the
		# WebSocket client support Outbound and Path.
		add_contact_alias();
	}
}



event_route[xhttp:request] {
	set_reply_close();
	set_reply_no_connect();

	#if ($Rp != MY_WS_PORT && $Rp != MY_WSS_PORT ) {
	#	xlog("L_WARN", "HTTP request received on $Rp\n");
	#	xhttp_reply("403", "Forbidden", "", "");
	#	exit;
	#}

	xlog("L_DBG", "HTTP Request Received $Rp port \n");

	if ($hdr(Upgrade)=~"websocket" && $hdr(Connection)=~"Upgrade" && $rm=~"GET") {

		# Validate Host - make sure the client is using the correct alias for WebSockets
		if ($hdr(Host) == $null || !is_myself("sip:" + $hdr(Host))) {
			xlog("L_WARN", "Bad host $hdr(Host)\n");
			xhttp_reply("403", "Forbidden", "", "");
			exit;
		}

		# Optional... validate Origin - make sure the client is from an
		# authorised website.  For example,
		#
		# if ($hdr(Origin) != "http://communicator.MY_DOMAIN"
		#     && $hdr(Origin) != "https://communicator.MY_DOMAIN") {
		#	xlog("L_WARN", "Unauthorised client $hdr(Origin)\n");
		#	xhttp_reply("403", "Forbidden", "", "");
		#	exit;
		# }

		# Optional... perform HTTP authentication

		# ws_handle_handshake() exits (no further configuration file
		# processing of the request) when complete.
		if (ws_handle_handshake())
		{
			# Optional... cache some information about the
			# successful connection
			exit;
		}
	}

	xhttp_reply("404", "Not Found", "", "");
}

event_route[websocket:closed] {
	xlog("L_INFO", "WebSocket connection from $si:$sp has closed\n");
}